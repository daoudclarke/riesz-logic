assign(max_seconds, 30).


op(600, infix, "=>"). % Riesz space implication


formulas(sos).

% Inference rule

P(x) & P(x => y) -> P(y)             # label(MP).

% Godel's rule
%P(x) -> P(x ^ x)                     # label(G).

% Axioms for Riesz space logic

% These two together allow proof of first five BAL axioms
P((x => y) => ((y => z) => (x => z))) # label(BL1).
P(((y => z) => (x => z)) => (x => y)) # label(BL1a).

% Needed to prove BALPI and BALPa
P(x ^ y => x)                         # label(BL2).

% Needed to prove BALO
P(x ^ y => y ^ x)                     # label(BL3).

% Adapted from BAL
%P(x ^ y => (x ^ y) ^ y).
%P((x => 0) ^ 0 => ((x => 0) ^0) ^ 0).
%P(((x => 0) ^ 0) ^ 0 => x ^ 0).


% Taken from BAL

%% P(((x v 0) v 0) => x v 0).

%% P(((x => y) v 0 => (y => x) v 0) => (y => x)).
%% P((y => x) => ((x => y) v 0 => (y => x) v 0)).


% Seemingly can't prove these ones:
%P(x ^ y => (x ^ y) ^ y).
%P(x => x ^ x).
%P((z => (x ^ y)) => ((z => x) ^ (z => y))) # label(R1a).
%P(((z => x) ^ (z => y)) => (z => (x ^ y))) # label(R1b).
% Negation reverses entailment
%P(((x => y) => (z => u)) => ((u => z) => (y => x))).

% Monotonicity of conjunction
P((x => y) => (z ^ x => z ^ y)).


% Definition of zero

P(0 => (z => z)).
P((z => z) => 0).

% Definition of join

P(x v y => (((x => 0) ^ (y => 0)) => 0)).
P((((x => 0) ^ (y => 0) => 0)) => x v y).

%P(x ^ y => (((x => 0) v (y => 0)) => 0)).
%P((((x => 0) v (y => 0) => 0)) => x ^ y).

% old definition:
%% P(x v y) <-> P( ((x => (z => z)) ^ (y => (v5 => v5))) => (v6 => v6)).
%% P(x v y) <-> P(((x => 0) ^ (y => 0)) => 0).

end_of_list.

formulas(hints).

P(x) & P(x => y) -> P(y) # label(MP) # label(non_clause).
P((((x => 0) ^ 0) v 0 => 0) => x v 0) # label(non_clause) # label(goal).
-P(x) | -P(x => y) | P(y) # label(MP).
P((x => y) => ((y => z) => (x => z))) # label(BL1).
P(((x => y) => (z => y)) => (z => x)) # label(BL1a).
P(x ^ y => x) # label(BL2).
P(x ^ y => y ^ x) # label(BL3).
P(0 => (x => x)).
P((x => x) => 0).
P(((x => 0) ^ (y => 0) => 0) => x v y).
-P((((c1 => 0) ^ 0) v 0 => 0) => c1 v 0).
P((((x => y) => (z => y)) => u) => ((z => x) => u)).
P(x => ((x => y) => y)).
P((x => y) => (x ^ z => y)).
P((x ^ y => z) => (y ^ x => z)).
P(((x => x) => y) => (0 => y)).
P((x => x) ^ y => 0).
P(x ^ (y => y) => 0).
P(x v 0).
P((x v 0 => y) => y).
P(0 => x v 0).
P(((0 => x v 0) => y) => y).
P((x => 0) => (x => y v 0)).
P((x v 0 => 0) => y v 0).

P(x) & P(x => y) -> P(y) # label(MP) # label(non_clause).
P(((x => 0) => 0) => x) # label(non_clause) # label(goal).
-P(x) | -P(x => y) | P(y) # label(MP) # label(non_clause).
P((x => y) => ((y => z) => (x => z))) # label(BL1).
P(((x => y) => (z => y)) => (z => x)) # label(BL1a).
-P(((c2 => 0) => 0) => c2).
P(((x => y) => y) => x).

% 9 hints from 2 proof(s) in file zero.out, Thu Jun 26 13:53:29 2014

P(x) & P(x => y) -> P(y) # label(MP) # label(non_clause).
P(x => ((x => y) => y)) # label(non_clause) # label(goal).
-P(x) | -P(x => y) | P(y) # label(MP) # label(non_clause).
P(((x => y) => (z => y)) => (z => x)) # label(BL1a).
-P(c5 => ((c5 => c6) => c6)).
$F.
P(((x => y) => y) => x) # label(non_clause) # label(goal).
P((x => y) => ((y => z) => (x => z))) # label(BL1).
-P(((c3 => c4) => c4) => c3).

% 9 hints from 1 proof(s) in file negation.out, Thu Jun 26 14:20:43 2014

P(x) & P(x => y) -> P(y) # label(MP) # label(non_clause).
P((x => 0) => 0) -> P(x) # label(non_clause) # label(goal).
-P(x) | -P(x => y) | P(y) # label(MP) # label(non_clause).
P((x => y) => ((y => z) => (x => z))) # label(BL1).
P(((x => y) => (z => y)) => (z => x)) # label(BL1a).
P((c7 => 0) => 0).
-P(c7).
P(((x => y) => y) => x).
$F.

% 4 hints from 1 proof(s) in file stdin, Thu Jun 26 14:33:35 2014

P((x => 0) ^ (y => 0) => (x => 0)) # label(non_clause) # label(goal).
P(x ^ y => x) # label(BL2).
-P((c8 => 0) ^ (c9 => 0) => (c8 => 0)).
$F.

%% % Manually constructed

%% P((x => 0) ^ (y => 0) => ((((x => 0) => 0) v ((y => 0) => 0)) => 0)) # label(non_clause) # label(goal).
%% P(x v y => (((x => 0) ^ (y => 0)) => 0)) #label(non_clause).
%% P(x ^ y => x) # label(BL2).
%% -P((c8 => 0) ^ (c9 => 0) => (c8 => 0)).
%% $F.


end_of_list.

% set(restrict_denials).

formulas(goals).

% BAL axioms. These come in pairs since we are asserting positivity
% rather than equality to zero.

% Proven: -----------------------------------

%P((x => y) => ((z => x) => (z => y))). 
%P(((z => x) => (z => y)) => (x => y)).

%P((x => (y => z)) => (y => (x => z))).

%P(((x => y) => y) => x).
%P(x => ((x => y) => y)).

%P(x v 0 => ((x v 0) v 0)) # label(BALPa).


% -------------------------------------------

% Unproven:

%% P(((x v 0) v 0) => x v 0).

%% P(((x => y) v 0 => (y => x) v 0) => (y => x)).
%% P((y => x) => ((x => y) v 0 => (y => x) v 0)).

% BAL inference rules

% Proven:

% P(x) -> P(x v 0)                                             # label(BALPI).
% P(x) & P(x => y) -> P(y)                                     # label(MP).     % Assumed
% P((x => y) v 0) -> P((x v 0 => y v 0) v 0)                   # label(BALMI).
% P(x) & P(x => 0) & P(y) & P(y => 0) -> P(x => y) & P(y => x) # label(BALG).

% Other goals we are interested in

%% P((z => (x ^ y)) => ((z => x) ^ (z => y))) # label(R1a).
%% P(x ^ y => (x ^ y) ^ y).
%% P((x v y) v y => x v y).
%% P(x => x ^ x).
%% P(((x => y) => (z => u)) => ((u => z) => (y => x))).
%% P(((x => 0) => 0) => x).

%% % Double negation - Proved
%% P(((x => y) => y) => x).
%% P(x => ((x =>y) => y)).

%P((x => 0) => 0) -> P(x).

% Other properties of join

%P((x => 0) v (y => 0) => (((x => 0) => 0) ^ ((y => 0) => 0) => 0)).
%P((((x => 0) => 0) ^ ((y => 0) => 0) => 0) => ((x => 0) => 0) ^ (y => 0)).

%P(x ^ ((y => 0) => 0) => x ^ y).
%P(x => y) -> P(z ^ x => z ^ y).
%P((x => y) => (z ^ x => z ^ y)).

%P(x ^ y => (((x => 0) v (y => 0)) => 0)).
%P((((x => 0) v (y => 0) => 0)) => x ^ y).

% Adapted from BAL
%P(x ^ y => (x ^ y) ^ y).

%P(x ^ y => x)                         # label(BL2).

% Do we need a definition of zero?
P((x => x) => (y => y)).

% Simple negation of one of our rules
%P((x => 0) ^ (y => 0) => (x => 0)).


% Idempotence of + operator
%P((x => 0) ^ 0 => ((x => 0) ^0) ^ 0).
%P((((x => 0) ^0) ^ 0 => 0) => ((x => 0) ^ 0 => 0)).
%P((((x => 0) ^ 0) v 0 => 0) => x v 0).
%P((((x => 0) ^ 0) v 0 => 0) => x v 0).
%P(((((x => 0) => 0) v (0 => 0)) => 0) v 0 => 0).

% A different route
%P((x ^ y) => (x ^ y) ^ y).
%P(((x => 0) v (y => 0) => 0) => x ^ y).
%P(((x => 0) v (y => 0) => 0) => (x ^ y) ^ y).
%P((x ^ y) ^ y => (((x ^ y) => 0) v (y => 0) => 0)).
%P((x ^ y) ^ y => ((((x => 0) v (y => 0)) v (y => 0)) => 0)).
%P( ((x => 0) v (y => 0) => 0) => ((((x => 0) v (y => 0)) v (y => 0)) => 0)).

% Proven with monotonicity of conjunction condition
%P(((x v 0) v 0) => x v 0).

end_of_list.
